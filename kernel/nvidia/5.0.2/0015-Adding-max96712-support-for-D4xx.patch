From 74a30d41e7972e0e9c2d60744cea1b43dd7c3b08 Mon Sep 17 00:00:00 2001
From: ejgoldik <ehud.joseph.goldik@realsenseai.com>
Date: Wed, 18 Feb 2026 11:52:13 +0200
Subject: [PATCH] Adding max96712 support for D4xx

Signed-off-by: ejgoldik <ehud.joseph.goldik@realsenseai.com>
---
 drivers/media/i2c/max96712.c | 310 ++++++++++++++++++++++++++++++++++-
 1 file changed, 308 insertions(+), 2 deletions(-)

diff --git a/drivers/media/i2c/max96712.c b/drivers/media/i2c/max96712.c
index 8081385f0..3de1643bc 100644
--- a/drivers/media/i2c/max96712.c
+++ b/drivers/media/i2c/max96712.c
@@ -21,17 +21,55 @@
 #include <linux/debugfs.h>
 #include <media/camera_common.h>
 #include <linux/module.h>
+#include <media/max96712.h>
+#include <linux/of_gpio.h>
 
+/* register specifics */
+
+#define MAX96712_REG6_ADDR 0x6
+#define MAX96712_CTRL1_ADDR 0x18
+
+#define MAX96712_BACKTOP25_ADDR 0x418
+
+#define MAX96712_MIPI_PHY0_ADDR 0x8A0
+#define MAX96712_MIPI_PHY2_ADDR 0x8A2
+#define MAX96712_MIPI_PHY3_ADDR 0x8A3
+#define MAX96712_VIDEO_PIPE_SEL_0_ADDR 0xF0
+#define MAX96712_VIDEO_PIPE_SEL_1_ADDR 0xF1
+#define MAX96712_VIDEO_PIPE_EN_ADDR 0xF4
+#define MAX96712_BACKTOP12_CSI_OUT_EN_ADDR 0x40B
+
+#define MAX96712_MIPI_TX10_ADDR 0x94A
+#define MAX96712_MIPI_TX11_ADDR 0x90B
+#define MAX96712_MIPI_TX13_SRC_0_MAP_ADDR 0x90D
+#define MAX96712_MIPI_TX14_DST_0_MAP_ADDR 0x90E
+#define MAX96712_MIPI_TX15_SRC_1_MAP_ADDR 0x90F
+#define MAX96712_MIPI_TX16_DST_1_MAP_ADDR 0x910
+#define MAX96712_MIPI_TX17_SRC_2_MAP_ADDR 0x911
+#define MAX96712_MIPI_TX18_DST_2_MAP_ADDR 0x912
+#define MAX96712_MIPI_TX19_SRC_3_MAP_ADDR 0x913
+#define MAX96712_MIPI_TX20_DST_3_MAP_ADDR 0x914
+#define MAX96712_MIPI_TX45_MAP_DPHY_DEST_ADDR 0x92D
+#define MAX96712_MIPI_TX51_ADDR 0x973
+
+#define MAX96712_VIDEO_RX0_ADDR 0x100
+
+#define MAX96712_DPLL_0_ADDR 0x1D00
+
+/* data defines */
+#define MAX96712_MAX_PIPES 4
 
 struct max96712 {
 	struct i2c_client *i2c_client;
 	struct regmap *regmap;
 	const char *channel;
+	struct mutex lock;
+	int pwdn_gpio;
 };
 struct max96712 *global_priv[4] ;
 
 
-int max96712_write_reg_Dser(int slaveAddr,int channel,
+int max96712_write_reg_Dser(int slaveAddr, int channel,
 			u16 addr, u8 val)
 {
 	struct i2c_client *i2c_client = NULL;
@@ -99,6 +137,20 @@ static int max96712_read_reg(struct max96712 *priv,
 	return err;
 }
 
+static int max96712_write_reg(struct max96712 *priv,
+			u16 addr, unsigned int val)
+{
+	struct i2c_client *i2c_client = priv->i2c_client;
+	int err;
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+	return err;
+}
 
 static int max96712_stats_show(struct seq_file *s, void *data)
 {
@@ -169,7 +221,10 @@ static int max96712_debugfs_init(const char *dir_name,
 	if (np) {
 		err = of_property_read_string(np, "channel", &priv->channel);
 		if (err)
+		{
 			dev_err(&i2c_client->dev, "channel not found\n");
+			return -EINVAL;
+		}
 
 		err = snprintf(dev_name, sizeof(dev_name), "max96712_%s", priv->channel);
 		if (err < 0)
@@ -216,6 +271,7 @@ static int max96712_probe(struct i2c_client *client,
 {
 	struct max96712 *priv;
 	int err = 0;
+	struct device_node *np = NULL;
 
 	dev_info(&client->dev, "%s: enter\n", __func__);
 
@@ -228,10 +284,23 @@ static int max96712_probe(struct i2c_client *client,
 			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
 		return -ENODEV;
 	}
+	mutex_init(&priv->lock);
+
+	np = client->dev.of_node;
+	if (np) {
+		priv->pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
+		if (priv->pwdn_gpio < 0) {
+			dev_err(&client->dev,"%s: Could not retrieve pwdn_gpio = %d\n",
+				__func__, priv->pwdn_gpio);
+		}
+	}
+	dev_set_drvdata(&client->dev, priv);
 
 	err = max96712_debugfs_init(NULL, NULL, NULL, priv);
 	if (err)
+	{
 		return err;
+	}
 
 	/*set daymode by fault*/
 	dev_info(&client->dev, "%s:  success\n", __func__);
@@ -243,8 +312,12 @@ static int max96712_probe(struct i2c_client *client,
 static int
 max96712_remove(struct i2c_client *client)
 {
+	struct max96712 *priv;
 
 	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+
+		mutex_destroy(&priv->lock);
 		i2c_unregister_device(client);
 		client = NULL;
 	}
@@ -252,13 +325,245 @@ max96712_remove(struct i2c_client *client)
 	return 0;
 }
 
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+static int max96712_set_registers(struct max96712 *priv, struct reg_pair *map, u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max96712_write_reg(priv, map[j].addr, map[j].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+int max96712_get_available_pipe_id(struct device *dev, int vc_id)
+{
+	/* TODO EHUD: Currently vc_id == pipe id but that's definitely
+	 * not the end goal if we plan to support multiple cameras
+	 */
+	return vc_id;
+}
+EXPORT_SYMBOL(max96712_get_available_pipe_id);
+
+int max96712_release_pipe(struct device *dev, int pipe_id)
+{
+	/* TODO EHUD: pipe id? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_release_pipe);
+
+void max96712_reset_oneshot(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	max96712_write_reg(priv, MAX96712_CTRL1_ADDR, 0x0F);
+	msleep(100);
+}
+EXPORT_SYMBOL(max96712_reset_oneshot);
+
+static int __max96712_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 vc_id)
+{
+	int err = 0;
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	int i = 0;
+
+	struct reg_pair map_pipe_control[] = {
+		// Enable 4 mappings for Pipe X
+		{MAX96712_MIPI_TX11_ADDR, 0x0F},
+		// Map data_type1 on vc_id
+		{MAX96712_MIPI_TX13_SRC_0_MAP_ADDR, 0x1E},
+		{MAX96712_MIPI_TX14_DST_0_MAP_ADDR, 0x1E},
+		// Map frame_start on vc_id
+		{MAX96712_MIPI_TX15_SRC_1_MAP_ADDR, 0x00},
+		{MAX96712_MIPI_TX16_DST_1_MAP_ADDR, 0x00},
+		// Map frame end on vc_id
+		{MAX96712_MIPI_TX17_SRC_2_MAP_ADDR, 0x01},
+		{MAX96712_MIPI_TX18_DST_2_MAP_ADDR, 0x01},
+		// Map data_type2 on vc_id
+		{MAX96712_MIPI_TX19_SRC_3_MAP_ADDR, 0x12},
+		{MAX96712_MIPI_TX20_DST_3_MAP_ADDR, 0x12},
+		// All mappings to PHY1 (master for port A)
+		{MAX96712_MIPI_TX45_MAP_DPHY_DEST_ADDR, 0x55},
+		// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+		{MAX96712_VIDEO_RX0_ADDR, 0x23}, // pipe X
+	};
+
+	for (i = 0; i < (ARRAY_SIZE(map_pipe_control) - 1); i++) {
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	}
+	map_pipe_control[(ARRAY_SIZE(map_pipe_control) - 1)].addr += 0x12 * pipe_id;
+
+	if (data_type2 == 0x0) {
+		/* For IMU (which has no metadata) we override mapping
+		* to enable only 3
+		*/
+		map_pipe_control[0].val = 0x07;
+	}
+	map_pipe_control[1].val = (vc_id << 6) | data_type1;
+	map_pipe_control[2].val = (vc_id << 6) | data_type1;
+	map_pipe_control[3].val = (vc_id << 6) | 0x00;
+	map_pipe_control[4].val = (vc_id << 6) | 0x00;
+	map_pipe_control[5].val = (vc_id << 6) | 0x01;
+	map_pipe_control[6].val = (vc_id << 6) | 0x01;
+	map_pipe_control[7].val = (vc_id << 6) | data_type2;
+	map_pipe_control[8].val = (vc_id << 6) | data_type2;
+
+	err |= max96712_set_registers(priv, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	max96712_reset_oneshot(dev);
+	max96712_write_reg(priv, MAX96712_VIDEO_PIPE_EN_ADDR, 0xF);
+
+	return err;
+}
+
+int max96712_init_settings(struct device *dev)
+{
+	int err = 0;
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct reg_pair map_pipe_opt[] =
+	{
+		/* ----------Video pipes configure ----------------------*/
+		{MAX96712_REG6_ADDR, 0xF1}, // Enable link - Why is this needed?
+		{MAX96712_VIDEO_PIPE_SEL_0_ADDR, 0x10}, //0xF0, Link A ID 0 to pipe 0 , Link A ID 1 to pipe 1
+		{MAX96712_VIDEO_PIPE_SEL_1_ADDR, 0x32}, //0xF1, Link A ID 2 to pipe 2 , Link A ID 3 to pipe 3
+		{MAX96712_VIDEO_PIPE_EN_ADDR, 0x00}, //0xF4, Enable pipe 0-3, 0xFF
+	};
+
+	struct reg_pair map_phy_opt[] =
+	{
+		/* MIPI D-PHY Config */
+		{MAX96712_MIPI_PHY0_ADDR, 0x04}, //0x8A0
+		{MAX96712_MIPI_TX10_ADDR, 0x40}, //0x94a - MIPI lane count
+		{MAX96712_MIPI_PHY3_ADDR, 0xe4}, //0x8A3, Lower phys to lower lanes
+
+		/* Put DPLL in reset before changing MIPI lane rates */
+		{MAX96712_DPLL_0_ADDR, 0xF4}, //0x1D00
+
+		/* 1500Mbps/lane on port A */
+		{MAX96712_BACKTOP25_ADDR, 0x2f}, //0x418
+
+		/* Release DPLL reset */
+		{MAX96712_DPLL_0_ADDR, 0xF5}, //0x1D00
+
+		/* ALT2_MEM_MAP8 */
+		{MAX96712_MIPI_TX51_ADDR, 0x10}, //MIPI TX1
+
+		{MAX96712_MIPI_PHY2_ADDR, 0x34}, //0x8A2 Disable phys 2+3
+		{MAX96712_BACKTOP12_CSI_OUT_EN_ADDR, 0x02},  // (CSI_OUT_EN): CSI output enabled
+	};
+
+	mutex_lock(&priv->lock);
+
+	err |= max96712_set_registers(priv, map_pipe_opt, ARRAY_SIZE(map_pipe_opt));
+	err |= max96712_set_registers(priv, map_phy_opt, ARRAY_SIZE(map_phy_opt));
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_init_settings);
+
+int max96712_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 vc_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX96712_MAX_PIPES - 1)) {
+		dev_info(dev, "%s, input pipe_id: %d exceed max96712 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, vc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max96712_set_pipe(dev, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_set_pipe);
+
+int max96712_setup_link(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_setup_link);
+
+int max96712_setup_control(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_setup_control);
+
+int max96712_reset_control(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_reset_control);
+
+int max96712_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_sdev_register);
+
+int max96712_sdev_unregister(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_sdev_unregister);
+
+int max96712_power_on(struct device *dev)
+{
+    struct max96712 *priv = dev_get_drvdata(dev);
+    if (priv->pwdn_gpio > 0) {
+        gpio_direction_output(priv->pwdn_gpio, 1);
+        gpio_set_value(priv->pwdn_gpio, 1);
+        msleep(100);
+    }
+    return 0;
+}
+EXPORT_SYMBOL(max96712_power_on);
+
+void max96712_power_off(struct device *dev)
+{
+    struct max96712 *priv = dev_get_drvdata(dev);
+    if (priv->pwdn_gpio > 0) {
+        gpio_direction_output(priv->pwdn_gpio, 1);
+        gpio_set_value(priv->pwdn_gpio, 0);
+        msleep(100);
+    }
+    return;
+}
+EXPORT_SYMBOL(max96712_power_off);
+
 static const struct i2c_device_id max96712_id[] = {
 	{ "max96712", 0 },
 	{ },
 };
 
 const struct of_device_id max96712_of_match[] = {
-	{ .compatible = "nvidia,max96712", },
+	{ .compatible = "maxim,max96712", },
 	{ },
 };
 
@@ -268,6 +573,7 @@ static struct i2c_driver max96712_i2c_driver = {
 	.driver = {
 		.name = "max96712",
 		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max96712_of_match),
 	},
 	.probe = max96712_probe,
 	.remove = max96712_remove,
-- 
2.43.0

