From ddbef14471800b69c9ffc6a972a4911cd2c32ceb Mon Sep 17 00:00:00 2001
From: ejgoldik <ehud.joseph.goldik@realsenseai.com>
Date: Wed, 18 Feb 2026 11:24:20 +0200
Subject: [PATCH] Adding max96712 support for D4xx

Signed-off-by: ejgoldik <ehud.joseph.goldik@realsenseai.com>
---
 drivers/media/i2c/max96712.c | 335 +++++++++++++++++++++++++++++++----
 1 file changed, 300 insertions(+), 35 deletions(-)

diff --git a/drivers/media/i2c/max96712.c b/drivers/media/i2c/max96712.c
index 8e237eef..38f093e1 100644
--- a/drivers/media/i2c/max96712.c
+++ b/drivers/media/i2c/max96712.c
@@ -16,32 +16,64 @@
 #include <linux/gpio.h>
 #include <linux/of.h>
 #include <linux/of_gpio.h>
+#include <media/max96712.h>
 
+/* register specifics */
+
+#define MAX96712_REG6_ADDR 0x6
+#define MAX96712_CTRL1_ADDR 0x18
+
+#define MAX96712_BACKTOP25_ADDR 0x418
+
+#define MAX96712_MIPI_PHY0_ADDR 0x8A0
+#define MAX96712_MIPI_PHY2_ADDR 0x8A2
+#define MAX96712_MIPI_PHY3_ADDR 0x8A3
+#define MAX96712_VIDEO_PIPE_SEL_0_ADDR 0xF0
+#define MAX96712_VIDEO_PIPE_SEL_1_ADDR 0xF1
+#define MAX96712_VIDEO_PIPE_EN_ADDR 0xF4
+#define MAX96712_BACKTOP12_CSI_OUT_EN_ADDR 0x40B
+
+#define MAX96712_MIPI_TX10_ADDR 0x94A
+#define MAX96712_MIPI_TX11_ADDR 0x90B
+#define MAX96712_MIPI_TX13_SRC_0_MAP_ADDR 0x90D
+#define MAX96712_MIPI_TX14_DST_0_MAP_ADDR 0x90E
+#define MAX96712_MIPI_TX15_SRC_1_MAP_ADDR 0x90F
+#define MAX96712_MIPI_TX16_DST_1_MAP_ADDR 0x910
+#define MAX96712_MIPI_TX17_SRC_2_MAP_ADDR 0x911
+#define MAX96712_MIPI_TX18_DST_2_MAP_ADDR 0x912
+#define MAX96712_MIPI_TX19_SRC_3_MAP_ADDR 0x913
+#define MAX96712_MIPI_TX20_DST_3_MAP_ADDR 0x914
+#define MAX96712_MIPI_TX45_MAP_DPHY_DEST_ADDR 0x92D
+#define MAX96712_MIPI_TX51_ADDR 0x973
+
+#define MAX96712_VIDEO_RX0_ADDR 0x100
+
+#define MAX96712_DPLL_0_ADDR 0x1D00
+
+/* data defines */
+#define MAX96712_MAX_PIPES 4
 
 struct max96712 {
 	struct i2c_client *i2c_client;
 	struct regmap *regmap;
 	const char *channel;
+	struct mutex lock;
+	int pwdn_gpio;
 };
 static struct max96712 *global_priv[4];
 
 int max96712_write_reg_Dser(int slaveAddr, int channel, u16 addr, u8 val);
 int max96712_read_reg_Dser(int slaveAddr, int channel, u16 addr, unsigned int *val);
 
-struct mutex max96712_rw;
-
 int max96712_write_reg_Dser(int slaveAddr, int channel,
 				u16 addr, u8 val)
 {
 	struct i2c_client *i2c_client = NULL;
 	int bak = 0;
 	int err = 0;
-	/* unsigned int ival = 0; */
 
 	if (channel > 3 || channel < 0 || global_priv[channel] == NULL)
 		return -1;
-
-	mutex_lock(&max96712_rw);
 	i2c_client = global_priv[channel]->i2c_client;
 	bak = i2c_client->addr;
 
@@ -53,7 +85,6 @@ int max96712_write_reg_Dser(int slaveAddr, int channel,
 		dev_err(&i2c_client->dev, "%s: addr = 0x%x, val = 0x%x\n",
 				__func__, addr, val);
 	}
-	mutex_unlock(&max96712_rw);
 	return err;
 }
 EXPORT_SYMBOL(max96712_write_reg_Dser);
@@ -68,8 +99,6 @@ int max96712_read_reg_Dser(int slaveAddr, int channel,
 
 	if (channel > 3 || channel < 0 || global_priv[channel] == NULL)
 		return -1;
-
-	mutex_lock(&max96712_rw);
 	i2c_client = global_priv[channel]->i2c_client;
 	bak = i2c_client->addr;
 	i2c_client->addr = slaveAddr / 2;
@@ -80,7 +109,6 @@ int max96712_read_reg_Dser(int slaveAddr, int channel,
 		dev_err(&i2c_client->dev, "%s: addr = 0x%x, val = 0x%x\n",
 				__func__, addr, *val);
 	}
-	mutex_unlock(&max96712_rw);
 	return err;
 }
 EXPORT_SYMBOL(max96712_read_reg_Dser);
@@ -99,6 +127,20 @@ static int max96712_read_reg(struct max96712 *priv,
 	return err;
 }
 
+static int max96712_write_reg(struct max96712 *priv,
+			u16 addr, unsigned int val)
+{
+	struct i2c_client *i2c_client = priv->i2c_client;
+	int err;
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+	return err;
+}
 
 static int max96712_stats_show(struct seq_file *s, void *data)
 {
@@ -153,24 +195,6 @@ static const struct file_operations max96712_debugfs_fops = {
 	.release = single_release,
 };
 
-static int  max96712_power_on(struct max96712 *priv)
-{
-	struct i2c_client *i2c_client = priv->i2c_client;
-	struct device_node *np = i2c_client->dev.of_node;
-	unsigned int pwdn_gpio = 0;
-
-	if(np) {
-		pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
-		dev_info(&i2c_client->dev,"%s: pwdn_gpio = %d\n",__func__,pwdn_gpio);
-	}
-	if (pwdn_gpio > 0) {
-		gpio_direction_output(pwdn_gpio, 1);
-		gpio_set_value(pwdn_gpio, 1);
-		msleep(100);
-	}
-	return 0;
-}
-
 static int max96712_debugfs_init(const char *dir_name,
 				struct dentry **d_entry,
 				struct dentry **f_entry,
@@ -237,6 +261,7 @@ static int max96712_probe(struct i2c_client *client,
 {
 	struct max96712 *priv;
 	int err = 0;
+	struct device_node *np = NULL;
 
 	dev_info(&client->dev, "%s: enter\n", __func__);
 
@@ -249,15 +274,19 @@ static int max96712_probe(struct i2c_client *client,
 			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
 		return -ENODEV;
 	}
+	mutex_init(&priv->lock);
 
-	mutex_init(&max96712_rw);
-
-	err = max96712_power_on(priv);
-	if (err) {
-		dev_err(&client->dev, "Failed to power on err =%d\n",err);
-		return err;
+	np = client->dev.of_node;
+	if (np) {
+		priv->pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
+		if (priv->pwdn_gpio < 0) {
+			dev_err(&client->dev,"%s: Could not retrieve pwdn_gpio = %d\n",
+				__func__, priv->pwdn_gpio);
+		}
 	}
 
+	dev_set_drvdata(&client->dev, priv);
+
 	err = max96712_debugfs_init(NULL, NULL, NULL, priv);
 	if (err)
 		return err;
@@ -274,8 +303,11 @@ static int max96712_remove(struct i2c_client *client)
 static void max96712_remove(struct i2c_client *client)
 #endif
 {
-
+	struct max96712 *priv;
 	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+
+		mutex_destroy(&priv->lock);
 		i2c_unregister_device(client);
 		client = NULL;
 	}
@@ -284,13 +316,245 @@ static void max96712_remove(struct i2c_client *client)
 #endif
 }
 
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+static int max96712_set_registers(struct max96712 *priv, struct reg_pair *map, u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max96712_write_reg(priv, map[j].addr, map[j].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+int max96712_get_available_pipe_id(struct device *dev, int vc_id)
+{
+	/* TODO EHUD: Currently vc_id == pipe id but that's definitely
+	 * not the end goal if we plan to support multiple cameras
+	 */
+	return vc_id;
+}
+EXPORT_SYMBOL(max96712_get_available_pipe_id);
+
+int max96712_release_pipe(struct device *dev, int pipe_id)
+{
+	/* TODO EHUD: pipe id? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_release_pipe);
+
+void max96712_reset_oneshot(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	max96712_write_reg(priv, MAX96712_CTRL1_ADDR, 0x0F);
+	msleep(100);
+}
+EXPORT_SYMBOL(max96712_reset_oneshot);
+
+static int __max96712_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 vc_id)
+{
+	int err = 0;
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	int i = 0;
+
+	struct reg_pair map_pipe_control[] = {
+		// Enable 4 mappings for Pipe X
+		{MAX96712_MIPI_TX11_ADDR, 0x0F},
+		// Map data_type1 on vc_id
+		{MAX96712_MIPI_TX13_SRC_0_MAP_ADDR, 0x1E},
+		{MAX96712_MIPI_TX14_DST_0_MAP_ADDR, 0x1E},
+		// Map frame_start on vc_id
+		{MAX96712_MIPI_TX15_SRC_1_MAP_ADDR, 0x00},
+		{MAX96712_MIPI_TX16_DST_1_MAP_ADDR, 0x00},
+		// Map frame end on vc_id
+		{MAX96712_MIPI_TX17_SRC_2_MAP_ADDR, 0x01},
+		{MAX96712_MIPI_TX18_DST_2_MAP_ADDR, 0x01},
+		// Map data_type2 on vc_id
+		{MAX96712_MIPI_TX19_SRC_3_MAP_ADDR, 0x12},
+		{MAX96712_MIPI_TX20_DST_3_MAP_ADDR, 0x12},
+		// All mappings to PHY1 (master for port A)
+		{MAX96712_MIPI_TX45_MAP_DPHY_DEST_ADDR, 0x55},
+		// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+		{MAX96712_VIDEO_RX0_ADDR, 0x23}, // pipe X
+	};
+
+	for (i = 0; i < (ARRAY_SIZE(map_pipe_control) - 1); i++) {
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	}
+	map_pipe_control[(ARRAY_SIZE(map_pipe_control) - 1)].addr += 0x12 * pipe_id;
+
+	if (data_type2 == 0x0) {
+		/* For IMU (which has no metadata) we override mapping
+		* to enable only 3
+		*/
+		map_pipe_control[0].val = 0x07;
+	}
+	map_pipe_control[1].val = (vc_id << 6) | data_type1;
+	map_pipe_control[2].val = (vc_id << 6) | data_type1;
+	map_pipe_control[3].val = (vc_id << 6) | 0x00;
+	map_pipe_control[4].val = (vc_id << 6) | 0x00;
+	map_pipe_control[5].val = (vc_id << 6) | 0x01;
+	map_pipe_control[6].val = (vc_id << 6) | 0x01;
+	map_pipe_control[7].val = (vc_id << 6) | data_type2;
+	map_pipe_control[8].val = (vc_id << 6) | data_type2;
+
+	err |= max96712_set_registers(priv, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	max96712_reset_oneshot(dev);
+	max96712_write_reg(priv, MAX96712_VIDEO_PIPE_EN_ADDR, 0xF);
+
+	return err;
+}
+
+int max96712_init_settings(struct device *dev)
+{
+	int err = 0;
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct reg_pair map_pipe_opt[] =
+	{
+		/* ----------Video pipes configure ----------------------*/
+		{MAX96712_REG6_ADDR, 0xF1}, // Enable link - Why is this needed?
+		{MAX96712_VIDEO_PIPE_SEL_0_ADDR, 0x10}, //0xF0, Link A ID 0 to pipe 0 , Link A ID 1 to pipe 1
+		{MAX96712_VIDEO_PIPE_SEL_1_ADDR, 0x32}, //0xF1, Link A ID 2 to pipe 2 , Link A ID 3 to pipe 3
+		{MAX96712_VIDEO_PIPE_EN_ADDR, 0x00}, //0xF4, Enable pipe 0-3, 0xFF
+	};
+
+	struct reg_pair map_phy_opt[] =
+	{
+		/* MIPI D-PHY Config */
+		{MAX96712_MIPI_PHY0_ADDR, 0x04}, //0x8A0
+		{MAX96712_MIPI_TX10_ADDR, 0x40}, //0x94a - MIPI lane count
+		{MAX96712_MIPI_PHY3_ADDR, 0xe4}, //0x8A3, Lower phys to lower lanes
+
+		/* Put DPLL in reset before changing MIPI lane rates */
+		{MAX96712_DPLL_0_ADDR, 0xF4}, //0x1D00
+
+		/* 1500Mbps/lane on port A */
+		{MAX96712_BACKTOP25_ADDR, 0x2f}, //0x418
+
+		/* Release DPLL reset */
+		{MAX96712_DPLL_0_ADDR, 0xF5}, //0x1D00
+
+		/* ALT2_MEM_MAP8 */
+		{MAX96712_MIPI_TX51_ADDR, 0x10}, //MIPI TX1
+
+		{MAX96712_MIPI_PHY2_ADDR, 0x34}, //0x8A2 Disable phys 2+3
+		{MAX96712_BACKTOP12_CSI_OUT_EN_ADDR, 0x02},  // (CSI_OUT_EN): CSI output enabled
+	};
+
+	mutex_lock(&priv->lock);
+
+	err |= max96712_set_registers(priv, map_pipe_opt, ARRAY_SIZE(map_pipe_opt));
+	err |= max96712_set_registers(priv, map_phy_opt, ARRAY_SIZE(map_phy_opt));
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_init_settings);
+
+int max96712_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 vc_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX96712_MAX_PIPES - 1)) {
+		dev_info(dev, "%s, input pipe_id: %d exceed max96712 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, vc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max96712_set_pipe(dev, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_set_pipe);
+
+int max96712_setup_link(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_setup_link);
+
+int max96712_setup_control(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_setup_control);
+
+int max96712_reset_control(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_reset_control);
+
+int max96712_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_sdev_register);
+
+int max96712_sdev_unregister(struct device *dev, struct device *s_dev)
+{
+	/* TODO EHUD: Is needed? */
+	return 0;
+}
+EXPORT_SYMBOL(max96712_sdev_unregister);
+
+int max96712_power_on(struct device *dev)
+{
+    struct max96712 *priv = dev_get_drvdata(dev);
+    if (priv->pwdn_gpio > 0) {
+        gpio_direction_output(priv->pwdn_gpio, 1);
+        gpio_set_value(priv->pwdn_gpio, 1);
+        msleep(100);
+    }
+    return 0;
+}
+EXPORT_SYMBOL(max96712_power_on);
+
+void max96712_power_off(struct device *dev)
+{
+    struct max96712 *priv = dev_get_drvdata(dev);
+    if (priv->pwdn_gpio > 0) {
+        gpio_direction_output(priv->pwdn_gpio, 1);
+        gpio_set_value(priv->pwdn_gpio, 0);
+        msleep(100);
+    }
+    return;
+}
+EXPORT_SYMBOL(max96712_power_off);
+
 static const struct i2c_device_id max96712_id[] = {
 	{ "max96712", 0 },
 	{ },
 };
 
 static const struct of_device_id max96712_of_match[] = {
-	{ .compatible = "nvidia,max96712", },
+	{ .compatible = "maxim,max96712", },
 	{ },
 };
 
@@ -300,6 +564,7 @@ static struct i2c_driver max96712_i2c_driver = {
 	.driver = {
 		.name = "max96712",
 		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max96712_of_match),
 	},
 	.probe = max96712_probe,
 	.remove = max96712_remove,
-- 
2.43.0

